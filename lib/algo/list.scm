(library (algo list)
    (export andmap ormap index filter-map alist? remove/index)
    (import (rnrs (6)) (exn contract) (srfi srfi-69) (srfi srfi-28))
    
    (define (andmap p l)
        (unless (list? l)
            (raise-contract-error 'andmap "list?" l))
        (call/cc 
            (lambda (cc)
                (for-each (lambda (e) (unless (p e) (cc #f))) l)
                #t)))
    (define (ormap p l)
        (unless (list? l)
            (raise-contract-error 'ormap "list?" l))
        (call/cc
            (lambda (cc)
                (for-each (lambda (e) (if (p e) (cc #t))) l)
                #f)))
    (define (index l v eq)
        (unless (list? l)
            (raise-contract-error 'ormap "list?" l))
        (let loop ((i 0) (l l))
            (if (null? l)
                #f
                (let ((f (car l)) (r (cdr l)))
                    (if (eq f v)
                        i
                        (loop (+ i 1) r))))))
    (define (filter-map p l)
        (unless (list? l)
            (raise-contract-error 'filter-map "list?" l))
        (let loop ((l l))
            (if (null? l)
                '()
                (let ((f (car l))
                      (r (cdr l)))
                    (let ((v (p f)))
                        (if v (cons v (loop r)) (loop r)))))))
    (define (alist? l)
        (and (list? l) (andmap pair? l)))
    (define (remove/index l i)
        (unless (list? l)
            (raise-contract-error 'remove/index "list?" l))
        (unless (and (integer? i) (exact? i) (>= i 0) (< i (length l)))
            (raise-contract-error 'remove/index (format "(and/c exact-integer? (>=/c 0) (</c ~a))" (length l))))
        (let loop ((l l) (i i))
            (if (= i 0)
                (cdr l)
                (cons (car l) (loop (cdr l) (- i 1))))))
)