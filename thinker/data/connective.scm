(library (thinker data connective)
  (export & || ! and? or? not? children)
  (import (rnrs (6))
	        (thinker exn contract) 
          (thinker data primitive) (thinker data node))
  
  (define-record-type (And AND and?)
    (fields (immutable children and-children))
    (parent Node))
  (define-record-type (Or OR or?)
    (fields (immutable children or-children))
    (parent Node))
  (define-record-type (Not NOT not?)
    (fields (immutable children not-children))
    (parent Node))

  (define (check-node-list name l)
    (for-each
     (lambda (n)
       (unless (node? n)
	      (raise-contract-error name "node?" n)))
     l))
  
  (define (children rc)
    (cond ((and? rc) (and-children rc))
	  ((or? rc) (or-children rc))
	  ((not? rc) (not-children rc))
    (else (raise-contract-error 'children "(or/c and? or? not?)" rc))))

  (define (merge-children l pred)
    (let loop ((l l))
      (cond ((null? l) '())
            ((pred (car l)) (append (children (car l)) (loop (cdr l))))
            (else (cons (car l) (loop (cdr l)))))))

  (define (& . c)
    (check-node-list '& c)
    (AND (merge-children c and?)))
  (define (|| . c)
    (check-node-list '|| c)
    (OR (merge-children c or?)))
  (define (! c)
    (check-node-list '! (list c))
    (if (not? c)
        (car (not-children c))
        (NOT (list c))))
  )

